	/**
	 * 总结: 对象的初始化顺序:首先执行父类静态的内容，父类静态的内容执行完毕后， 接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，
	 * 再去看父类有没有非静态代码块，如果有就执行父类的非静态代码块，父类的非静态代码块执行完毕，
	 * 接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有非静态代码块，如果有就执行子类的非静态代码块。
	 * 子类的非静态代码块执行完毕再去执行子类的构造方法。总之一句话，静态代码块内容先执行，
	 * 接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法。
	 * 注意:子类的构造方法，不管这个构造方法带不带参数， 默认的它都会先去寻找父类的不带参数的构造方法。 如果父类没有不带参数的构造方法，
	 * 那么子类必须用super关键字来调用父类带参数的构造方法，否则编译不能通过。
	 -----------------------------------------------------------------
	 /**
	 * 重载是针对当前类的 方法名一样 参数列表的数据类型不一致 无关于返回值 访问修饰符
	 * 1.重写一定是在继承的前提下  
	 * 2.必须和父类方法名一样 方法的访问修饰符  返回值 参数列表一致
	 * 3.访问修饰符>=父类
	 * 4.一定是public protected
	 * 5.识别是通过重写父类的方法@Override
	 * 6.重写的目的是覆盖方法的业务逻辑,进而自己去实现    重写是多态的一种体现
	 */
	 -----------------------------------------------------------------------------
	 在一个类中，
	  属性和方法中又分为两种情况
	  
	 静态成员和非静态成员
	  static是不允许用来修饰局部变量。static不用new对象就可以使用了 就为了方便的调用  static属性方法 不可以调用
	  非静态的   被static修饰的东西只加载一次 不会被回收
	  
	   静态成员是属性---类本身的,不属于对象=--共享属性和方法
	   静态成员一定要静态方法中使用
	   
	   总结：
	  非静态方法即可调用静态成员，也可以调用非静态元素
	  静态方法中只能给你调用静态成员
	   
	   静态方法不允许被覆盖成非静态方法
	 	//静态成员在编译的时候就已经确定内存空间的大小，和当前类本身，存放入静态区中。---栈区
	//非静态成员，在new在申请空间地址的时候 创建的=---堆区
	//总结：
		//1:静态方法中只能调用静态成员
		//2:非静态方法可以调用静态成员也可以调用非静态成员
		//3:静态成员，一定通过类去调用，
		//4:既然静态方法属于类，没有对象的产生和那么方法就不能用this关键字
----------------------------------------------------------------------------------	
	/*
	 * 局部变量:
	 * 定义在方法或者代码块以内的变量就局部变量。
	 * 	1：如果使用了就一定赋值，
	 *  2：局部变量会随着方法的执行完毕，生命周期结束
	 *  在作用域是以{}为周期，如果{}以外那么就已经消亡
	 * */
	
	/**
	 * 构造函数: 
	 * 1.申请内存空间地址 创建对象 如果一个类中没有显式的定义构造函数，就会自动调用默认的构造函数 
	 * 2.收集属性和方法 给属性赋值
	 * 3.构造函数可以重载
	 * 4.构造函数必须与类名字一样  但是方法可以和类名一样 
	 * 
	 * 
	 * a.在调用之前执行方法
	 * b.在创建对象的时候会自动调用默认的构造函数 如果进行了构造函数的重载,那么就会覆盖原来的
	 * c.如果想继续使用原来的方法 就要显式的定义出来
	 * d.构造函数可以调用构造函数 例如你定义了一个构造方法有俩参数 下一个构造函数有三个参数 (参数1,参数2,参数3)
	 * 包括了前面俩个参数你可以将this(参数1,参数2)放到那个有三个参数的构造函数方法里面前提是必须放到第一行代码的位置上
	 * 
	 *  
	 * 方法重载:函数名字一样 参数不一样 参数列表不一致 void 没有返回值
	 * 方法修饰符 void name(){} 
	 * 方法修饰符 return_type name(){}
	 */
	---------------------------------------------------------------------------------
	/**
	 * Final:是用来修饰类，属性方法的关键字。
	 * 在java中每一个关键字它们是各司其职的，
	 * 配合使用是没有任何关系的，也不会改变每个关键词的修饰成员变量和属性 方法和类的特征.
	 * 被final修饰的引用数据类型不能是null
	 	没有被final修饰的变量byte，short，char相加后会自动提升为int
	 byte a = 1，b=2,c,d;
	 final byte a3 = 4,v = 6;
	 byte c = a3+v  不会报错
	 byte d = a+b 报错 
	 
	 * 
	 * 针对成员变量: 
	 * 被final修饰的成员变量是常量 只能赋值一次 
	 * final修饰的成员变量要赋值
	 * 赋值的方法：
	 * 非静态的：直接赋值  构造函数赋值 代码块赋值  
	 * 静态的final常量：就通过静态代码块或者直接赋值
	 * 
	 * 
	 * 针对局部变量:(方法中的变量)
	 * 可以不用赋初始值 但是只能被赋值一次
	 * 
	 * 被final修饰的成员变量是常量 是公开化的 不允许修改
	 * 常量公开的 必须大写 易于区分
	 final修饰的类：
 	它不可以有子类，也就不能被继承,如果在开发过程中，你不想有有任何的类来重写父类的方法或者派生出子类，
 	可以使用final修饰类。
	 */
	 --------------------------------------------------------------------------------------
	封装：
		
	封装是指：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。
	封装是面向对象贬称语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接直接操作和修改，就比如类中的Person
	对象的age变量，只能随着岁月的流逝，age才会增加，通常不能岁月修改属性的值，良好的封装有以下特点：
	
	1：隐藏类的实现细节
	2：让使用者只能通过实现预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问
	3:可进行数据检查，从而利用保证对象信息的完整性。
	4：便于修改，提供代码的可复用性和维护性
	
	
	最重要的两条就是：
	a:把对象的成员变量和实现细节隐藏起来，不允许外部直接访问
	b:把方法暴露出来，让方法控制对这些成员变量进行安全的访问和操作。
	这样做的目的就是为了统一行径，可以在方法中加入控制逻辑。
	-------------------------------------------------------------------------------------------
	
	继承：
	继承是面向对象的三大特征之一，也是实现软件复用的重要手段，Java具有单继承的特点每个子类只有一个直接父类。
	Java中的基础是通过extends关键字来实现的，实现继承的类称为子类，被继承的类被称为父类（超类，基类，大类）
	例如苹果继承了水果，苹果是子类，水果是父类。
	
	继承是把很多子类中相同的成员属性和方法定义父类的过程。
	
	super
	一定要有继承关系（父子关系）前提下，才会有super的概念
	当前类如果没有继承关系，执行一定的Object
	如果有继承关系，一定执行父类的引用和父类构造函数
	
	---他们都成员属性赋值操作
	
	给成员属性赋值一下：
	1：修饰符
	2:你属性是static,不是对象的范畴，调用类去调用
	3:final 值赋值一次
	------------------------------------------------------------------------------------------------
	抽象类：
	 *  不能实现化对象，但是可以定义构造函数.
	 *  实现抽象类，方式有两种---一种:通过匿名内部类，一种是：具体子类
	 *  1:抽象类必须使用abstract修饰，抽象方法必须用abstract修饰，抽象方法中不能又具体的实现。
	 *  2:抽象类不能被实例化对象的，但是可以定义构造函数，目的是给当前抽象类的私有成员属性赋值目的。（注：一种:通过匿名内部类，一种是：具体子类）
	 *  3：抽象方法，必须定义在抽象类中或者接口中。如果有抽象方法就要必然是抽象类或者接口。缺省情况下默认为public。
	 *  4:final不能够abstract共用
	 *  5:不能私有private 可以是public protected
	 *  6:没有抽象属性的概念
	 *  7:抽象类可以继承抽象类，也可以继承普通类，也可以实现接口.
	1:是语义上的角度来看，抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象，从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其字类的
	模板，从而子类设计的随意性。
	2:抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展，改造，但子类总体上回大致保留抽象类的行为方式。
	3:如果编写一个抽象父类，父类提供多个子类的通用方法，并把一个或多个方法留给器子类实现，这就是模板模式，
	4:如果父类中定义的普通方法一般都是给所有子类调用的方法，或者私有方法给自己调用的方法。
	5:抽象方法的类一定抽象类，抽象类不一定有抽象方法
	
	
	
	---------------------------------------------------------------------------------------
	多态：（存在继承的前提下）
	Java引用变量有有两个类型，一个是编译时的类型，一个是运行时的类型，编译时的类型由申明该变量时使用类型决定
	运行时的类型有实际赋给该变量的对象决定，
	如果编译时的类型和运行时的类型不一致的时候，就出现了所谓的多态。
	注意:多态的实例只能调用被子类覆盖的部分和父类公开的的 受保护的以及同包下面缺省的成员变量和方法
	
	 多态: 1.编译时的类型和运行时的不一样 而且有继承关系 
		  一、要有继承；
		  二、要有重写； 
		  三、父类引用指向子类对象。
		  
	
------------------------------------------------------------------------------------------
	访问修饰符总结： public > protected > default >private
	1:public private忽略它
	2:同包中：缺省的，protected只要在同一片文件夹下面（平级的类），可以被访问的
	3:不同包中：protected 一定是父子关系的情况下才能被访问成员属性和方法
	
	//  	 private	default 	 protected 		  public
		
	//同类中		是		   是			         是				是
		
	//同包中		否		   是			         是				是
				
	//子类中		否		   否			         是				是
		
	//全局中		否		   否			         否				是
	
	
	
	
	/*会话处理*/
	function setSession(key,value,mark){
		var stroage = mark?sessionStorage:localStorage;
		if(stroage)stroage.setItem(key, value);
	};
	
	
	function getSession(key,mark){
		var stroage = mark?sessionStorage:localStorage;
		if(stroage){
			return stroage.getItem(key);
		}else{
			return "";
		}
	};
	
	function removeSession(key,mark){
		var stroage = mark?sessionStorage:localStorage;
		if(stroage){
			return stroage.removeItem(key);
		}else{
			return "";
		}
	};	
	---------------------------------------------------------------------------------------------
	接口：
	定义格式：--接口的命名I开头
	[修饰符] interface 接口名称 extends 父接口1 
	{
		//零到多个常量定义
		//零到多个抽象方法定义
		//零到多个默认方法或类方法定义
		//零到多个内部类，接口，枚举定义....
	
	}	
	
	抽象类是从多个类中抽象出来的模板，如果将这种抽象进行更彻底，那么就是--接口（interface）
	1:接口中不能包含普通方法，接口里的所有方法都是抽象方法，（jdk1.8后对接口进行了改进，允许定义默认方法，默认方法可以提供方法的实现。）
	2:接口是从多个相似类中抽象出来的规范，接口不提供任何实现，接口体现的是规范和实现分离的设计哲学。
	3:接口让规范和实现分离，正是接口的好处，让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。例如主机板上提供了一个pci插槽，只要一个显卡遵守PCI接口规范
	就可以插入PCI插槽内。与主机板正常通信，至于这块显卡是哪个厂商制造的，内部是如何实现的，主板无须关心。
	类似的软件系统的各模块之间也应该采用这种面向接口
	耦合，从而尽量降低个模板之间的耦合，为系统提供更好的可扩展性和可维护性。
	
	4:接口不能继承抽象类和类，只能继承接口
	5:修饰符可以是public或者缺省的 ,默认采用缺省的访问修饰符。级只有在相同包结构下才可以访问接口方法。 缺省情况下默认public
	
	
	
	
	
	
	接口和抽象类：
	相同点：
	1：接口和抽象类都不能被实例化，它们都位于继承结构中的最顶端，用于被其他类实现和继承。
	2：接口和抽象类中都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。
	
	不同点：
	1：接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类可以有普通方法提供方法实现。
	2：接口只能定义静态常量，不能定义成普通成员变量，抽象都可以。
	3：接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成抽象类成员
	属性赋值和初始化的目的。
	4：接口不能包含代码块，抽象类中可以包含代码块。
	5：一个类最大只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口来弥补Java中单继承的概念
	
	接口和类公共写作完成了：Java中的单一继承，多实现的概念，单一继承指的是类和类（抽象类的）继承，实现讲的是接口。
	---------------------------------------------------------------------------------------
	接口的作用：
	1：通常接口是用来定义实现类的外观，也就是实现类的行为。接口相当于一份契约。根据外部应用需要的功能，约定了实现类应该实现的功能，但是具体的实现类实现接口
	约定的功能外，还可以根据需要实现一些其他的功能。是允许的，也就是说实现类的功能包含但不仅限于接口。
	2：接口的思想：就是封装隔离，通过提到封装是指对数据的封装，但是这里的封装是指“对隔离体的封装”或者是对“被隔离体的封装”。而隔离是值外部调用和内部实现
	，外部调用只能通过接口进行调用，而且外部调用是不知道内部具体的实现的，也就是说，外部调用和内部实现是被接口隔离开的。
	3：由于外部调用和内部实现被接口隔离开了，那么只要接口不变，内部实现的变化就不会受到影响到外部应用，而从的系统更加灵活，具有更好的扩展性和可维护性，也就
	是说“接口是系统可插拔行的保证”
	
	
	在开发中接口和抽象类的选择的标准：
	既然接口是一种特殊的抽象类，那么在开发中，何时选用接口，何时选用抽象类，对于它们的选择，在开发中是一个很重要的问题，
	1：优先选择接口。
	2：在如果下情况下选择抽象类，既要定义子类的行为，又要为子类提供公共的功能。	